#### 1. 栈



##### 1.1 单调栈

#### 2. 队列

##### 2.1单调队列

#### 3. 链表

#### 4. 数组

##### 4.1 数组排序

##### 4.2 前缀和

##### 4.3 二分查找

当查找数组中的某个值时，如果数组是单调有序的，单调递增或单调递减的，这个时候可以考虑使用二分。使用二分法时，考虑的问题主要有三个：

- 判断边界是否应当带等号
- mid是否应该加一
- 计算mid时是否出现溢出

针对第二个问题，mid是否应该加一，二分模板有两套，这根据`check(mid)==true`时需要调整的是==l指针==还是==r指针==来判断

- 当 `check(mid) == true` 调整的是 `l` 时：计算 `mid` 的方式应该为 `mid = l + r + 1 >> 1`：

```java
int l = 0, r = 1000009;
while (l < r) {
    int mid = l + r + 1 >> 1;
    if (check(mid)) {
        l = mid;
    } else {
        r = mid - 1;
    }
}
```

- 当 `check(mid) == true` 调整的是 `r` 时：计算 `mid` 的方式应该为 `mid = l + r >> 1`：

```java
int l = 0, r = 1000009;
while (l < r) {
    int mid = l + r >> 1;
    if (check(mid)) {
        r = mid;
    } else {
        l = mid + 1;
    }
}
```

- 为啥修改左边指针 `l` 的时候要进行 `+1` 操作？
   `+1` 操作主要是为了避免发生「死循环」，因为 >> 和 直接使用 / 一样，都属于「下取整」操作。
- 假设 l = 0, r = 1 的简单情况，如果不 +1 的话，l + r >> 1 等于 0 + 1 / 2，l 仍然是 0，陷入死循环。

##### 4.4 滑动窗口

##### 4.5 第K个最小元素

#### 5. 树

##### 5.1 二叉树

##### 5.2 字典树

##### 5.3 线段树

#### 6. 堆

#### 7. 并查集

[并查集](https://oi-wiki.org/ds/dsu/)

![img](https://oi-wiki.org/ds/images/disjoint-set.svg)

并查集是一种树形的数据结构，顾名思义，它用于处理一些不交集的 **合并** 及 **查询** 问题。 它支持两种操作：

- 查找（Find）：确定某个元素处于哪个子集；
- 合并（Union）：将两个子集合并成一个集合。

通俗地讲一个故事：几个家族进行宴会，但是家族普遍长寿，所以人数众多。由于长时间的分离以及年龄的增长，这些人逐渐忘掉了自己的亲人，只记得自己的爸爸是谁了，而最长者（称为「祖先」）的父亲已经去世，他只知道自己是祖先。为了确定自己是哪个家族，他们想出了一个办法，只要问自己的爸爸是不是祖先，一层一层的向上问，直到问到祖先。如果要判断两人是否在同一家族，只要看两人的祖先是不是同一人就可以了。

在这样的思想下，并查集的查找算法诞生了

- 路径压缩：把在路径上的每个节点都直接连接到根上，这就是路径压缩。
- 启发式合并：将一棵点数与深度都较小的集合树连接到一棵更大的集合树。

并查集模板-启发式合并，按秩压缩

```Java
class UnionFind{
    int[] parent;
    int[] size;
    
    public UnionFind(int k){
        parent=new int[k];
        size=new int[k];
        for(int i=0;i<k;i++){
            parent[i]=i;
        }
        Arrays.fill(size,1);
    }
    public int find(int x){
        while(x!=parent[x]) x=parent[x];
        return x;
    }
    public boolean connect(int x,int y){
        return find(x)==find(y);
    }
    // 把小的集合树加到大的集合树上
    public void union(int x,int y){
        int root_x=find(x);
        int root_y=find(y);
        if(root_x==root_y)return;
        if(size[root_x]<size[root_y]){
            int temp=root_x;
            root_x=root_y;
            root_y=temp;
        }
        parent[root_y]=root_x;
        size[root_x]+=size[root_y];
    }
}
```



#### 8. 图

##### 8.1 DFS和BFS

##### 8.2 欧拉路径

背景：

- 通过图中所有边恰好一次且行遍所有顶点的通路称为欧拉通路。
- 通过图中所有边恰好一次且行遍所有顶点的回路称为欧拉回路。
- 回路指最后又回到了起点，通路指终点与起点不同。
- 具有欧拉回路的无向图或有向图称为欧拉图。
- 具有欧拉通路但不具有欧拉回路的无向图或有向图称为半欧拉图。

一般求欧拉路径的算法为==Hierholzer 算法==，也称逐步插入回路法

Hierholzer 算法用于在连通图中寻找欧拉路径，其流程如下：

- 从起点出发，进行深度优先搜索。

- 每次沿着某条边从某个顶点移动到另外一个顶点的时候，都需要删除这条边。

- 如果没有可移动的路径，则将所在节点加入到栈中，并返回。


相关介绍：https://oi-wiki.org/graph/euler/

过程：求解欧拉路径，先要找到起点，根据图的入度和出度求起点，如果图中所有节点的入度和出度都相等，那么从任意节点开始都存在欧拉通路，存在欧拉回路；如果图中存在一个节点的出度比入度恰好多 1，另一个节点的入度恰好比出度多 1，那么欧拉通路必须从前一个节点开始，到后一个节点结束。除此之外的有向图都不存在欧拉通路，然后根据起点，使用逐步插入回路法，求得欧拉路径。

###### 8.2.1 欧拉路径模板题

[2097.合法重新排列数对](https://leetcode-cn.com/problems/valid-arrangement-of-pairs/)

> 给你一个下标从 0 开始的二维整数数组 pairs ，其中 `pairs[i] = [starti, endi]` 。如果 pairs 的一个重新排列，满足对每一个下标 i （` 1 <= i < pairs.length`）都有` endi-1 `== `starti` ，那么我们就认为这个重新排列是 pairs 的一个 合法重新排列 。
>
> 请你返回 任意一个 pairs 的合法重新排列。
>
> 注意：数据保证至少存在一个 pairs 的合法重新排列。
>

 示例 1：

> 输入：pairs = [[5,1],[4,5],[11,9],[9,4]]
> 输出：[[11,9],[9,4],[4,5],[5,1]]
> 解释：
> 输出的是一个合法重新排列，因为每一个 `endi-1` 都等于 `starti` 。
> `end0 = 9 == 9 = start1 
> end1 = 4 == 4 = start2
> end2 = 5 == 5 = start3`

>  示例 2：
> 输入：pairs = [[1,3],[3,2],[2,1]]
> 输出：[[1,3],[3,2],[2,1]]
> 解释：
> 输出的是一个合法重新排列，因为每一个` endi-1` 都等于 `starti` 。
> `end0 = 3 == 3 = start1
> end1 = 2 == 2 = start2`
> 重新排列后的数组 [[2,1],[1,3],[3,2]] 和 [[3,2],[2,1],[1,3]] 都是合法的。
> 示例 3：


提示：

> 1 <= `pairs.length` <= 105
> `pairs[i].length `== 2
> 0 <= `starti, endi` <= 109
> `starti != endi`
> pairs 中不存在一模一样的数对。
> 至少 存在 一个合法的 pairs 重新排列。

代码

```Java
class Solution {
    // 使用 in 这个哈希表来记录每个点的入度数是多少
    Map<Integer,Integer> in=new HashMap<>();
    // 使用 points 这个哈希表来记录每个点的下几个点
    Map<Integer,List<Integer>> points=new HashMap<>();
    int n;
    List<Integer> arr=new ArrayList<>();
    public int[][] validArrangement(int[][] pairs) {
        n=pairs.length;
        int[][] ans=new int[n][2];
        // 记录每个点的入度数和下个点
        for(int[] pair:pairs){
            int p1=pair[0],p2=pair[1];
            // 记录 点p2 的入度数
            in.put(p2,points.getOrDefault(p2,0)+1);
            // 记录 点p1 的下一个点
            List<Integer> list=points.getOrDefault(p1,new ArrayList<>());
            list.add(p2);
            points.put(p1,list);
        }
        // 获得起点位置，只有两种情况，要么出度数比入度数多一，要么所有点的出度数和入度数都相等
        int[] start=null;
        for(int[] pair:pairs){
            int p=pair[0];
            // points.getOrDefault(p,0) 点的入度数
            // points.get(p).size() 点的出度数
            if(points.getOrDefault(p,0)==points.get(p).size()-1)start=pair;
        }
        // 如果所有点的入度数和出度数都相等，那么这就是一个欧拉图，存在欧拉回路
        if(start==null)start=pairs[0];
        // 通过起点和逐步插入回路法获取欧拉路径
        dfs(start[0]);
        Collections.reverse(arr);
        for(int i=0;i<n;i++){
            ans[i]=new int[]{arr.get(i),arr.get(i+1)};
        }
        return ans;
    }
    // 逐步插入回路法
    // 这个算法的思想主要在于先找到死路，即终点加入arr
    public void dfs(int start){
        List<Integer> list=points.getOrDefault(start,new ArrayList<>());
        while(list!=null && list.size()>0){
            int temp=list.get(list.size()-1);
            list.remove(list.size()-1);
            //这两行代码可以变为一行，int temp=list.remove(list.size()-1);
            dfs(temp);
        }
        arr.add(start);
    }
}
```

 关于逐步插入回路法，如果只存在欧拉通路，先插入终点，再回到存在分路的地方

如1-->2-->3-->4-->5    和在顶点3上还有一条路   3-->6-->7-->3

<img src="C:\Users\wang\AppData\Roaming\Typora\typora-user-images\image-20211211162006067.png" alt="image-20211211162006067" style="zoom: 25%;" />

即点3的出度有点4和点6，当循环到点3时，如果先遍历点4，到终点5死路，list为null，就会依次插入点5，点4，然后点3执行另一条循环，再插入点6，点7，最后点3的list为null,再依次插入点3，点2，点1

如果是回路也是这样

###### 8.2.1 重新安排行程

[332. 重新安排行程](https://leetcode-cn.com/problems/reconstruct-itinerary/)

> 给你一份航线列表 tickets ，其中 tickets[i] = [from~i~, to~i~] 表示飞机出发和降落的机场地点。请你对该行程进行重新规划排序。
>
> 所有这些机票都属于一个从 JFK（肯尼迪国际机场）出发的先生，所以该行程必须从 JFK 开始。如果存在多种有效的行程，请你按字典排序返回最小的行程组合。
>
> 例如，行程` ["JFK", "LGA"] 与 ["JFK", "LGB"]` 相比就更小，排序更靠前。
> 假定所有机票至少存在一种合理的行程。且所有的机票 必须都用一次 且 只能用一次。

示例 1：

> 输入：`tickets = [["MUC","LHR"],["JFK","MUC"],["SFO","SJC"],["LHR","SFO"]]`
> 输出：`["JFK","MUC","LHR","SFO","SJC"]`

![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary1-graph.jpg)

示例 2：

> 输入：`tickets = [["JFK","SFO"],["JFK","ATL"],["SFO","ATL"],["ATL","JFK"],["ATL","SFO"]]`
> 输出：`["JFK","ATL","JFK","SFO","ATL","SFO"]`
> 解释：另一种有效的行程是` ["JFK","SFO","ATL","JFK","ATL","SFO"]` ，但是它字典排序更大更靠后。

![img](https://assets.leetcode.com/uploads/2021/03/14/itinerary2-graph.jpg)


提示：

> `1 <= tickets.length <= 300
> tickets[i].length == 2
> fromi.length == 3
> toi.length == 3`
> `fromi 和 toi` 由大写英文字母组成
> `fromi != toi`

```Java
class Solution {
    Map<String,PriorityQueue<String>> edges=new HashMap<>();
    // List<List<String>> paths=new ArrayList<>();
    List<String> path;
    public List<String> findItinerary(List<List<String>> tickets) {
        int n=tickets.size();
        for(List<String> ticket:tickets){
            PriorityQueue<String> edge=edges.getOrDefault(ticket.get(0),new PriorityQueue<>());
            edge.offer(ticket.get(1));
            edges.put(ticket.get(0),edge);
        }
        path=new LinkedList<>();
        dfs("JFK");
        Collections.reverse(path);
        return path;
    }
    public void dfs(String start){
        PriorityQueue<String> list=edges.getOrDefault(start,new PriorityQueue<>());
        while(list!=null && list.size()>0){
            String loc=list.poll();
            dfs(loc);
        }
        path.add(start);
    }
}
```

###### 8.2.3 破解保险箱

[753. 破解保险箱](https://leetcode-cn.com/problems/cracking-the-safe/)

> 有一个需要密码才能打开的保险箱。密码是 n 位数, 密码的每一位是 k 位序列 0, 1, ..., k-1 中的一个 。
>
> 你可以随意输入密码，保险箱会自动记住最后 n 位输入，如果匹配，则能够打开保险箱。
>
> 举个例子，假设密码是 "345"，你可以输入 "012345" 来打开它，只是你输入了 6 个字符.
>
> 请返回一个能打开保险箱的最短字符串。
>

示例1:

> 输入: n = 1, k = 2
> 输出: "01"
> 说明: "10"也可以打开保险箱。


示例2:

> 输入: n = 2, k = 2
> 输出: "00110"
> 说明: "01100", "10011", "11001" 也能打开保险箱。


提示：

> n 的范围是 [1, 4]。
> k 的范围是 [1, 10]。
> k^n 最大可能为 4096。

![image-20211211165515155](C:\Users\wang\AppData\Roaming\Typora\typora-user-images\image-20211211165515155.png)

解答视频： https://www.youtube.com/watch?v=iPLQgXUiU14

代码

```Java
class Solution {
    Set<Integer> set=new HashSet<>();
    StringBuilder sb=new StringBuilder();
    int highest,k;
    public String crackSafe(int n, int k) {
        this.k=k;
        highest=(int)Math.pow(10,n-1);
        dfs(0);
        for(int i=1;i<n;i++){
            sb.append('0');
        }
        return sb.toString();
    }
    public void dfs(int start){
        for(int x=0;x<k;x++){
            int node=start*10+x;
            if(!set.contains(node)){
                set.add(node);
                dfs(node%highest);
                sb.append(x);
            }
        }
        
    }
}
```



##### 8.3 最小生成树

##### 8.4 最短路径

#### 9. 其他模板

##### 9.1 快速乘法模板

主要思想是倍增

```java
long mul(long a, long k) {
    long ans = 0;
    while (k > 0) {
        if ((k & 1) == 1) ans += a;
        k >>= 1;
        a += a;
    }
    return ans;
}
```

