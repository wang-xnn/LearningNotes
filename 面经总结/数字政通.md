### 数字政通

#### 提前面经汇总

##### 1. Redis 的过期策略，和内存淘汰机制

Redis对设置了过期时间的键值对主要有3种策略：

1）定时删除，设置一个计时器，一旦过期了，马上删除，对内存友好，对CPU不友好

2）惰性删除，过期了不管，只有当要再用到这个键时，才会检测一下这个键有没有过期，过期了就删除，对CPU友好，对内存不友好

3）定期删除：将设置了过期时间的键放入expire字典中，设定一个时间，规定多少时间检查一次，删除过期的键

```SHELL
config set hz    #设置定期删除，每秒刷新多少次
```

> 1. 从过期字典中随机 20 个 key；
> 2. 删除这 20 个 key 中已经过期的 key；
> 3. 如果过期的 key 比率超过 1/4，那就重复步骤 1；

Redis中同时使用惰性删除和定期删除2种策略

内存淘汰机制

- noeviction：当内存不足以容纳新写入数据时，新写入操作会报错。
- allkeys-lru：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key。
- allkeys-random：当内存不足以容纳新写入数据时，在键空间中，随机移除某个key。
- volatile-lru：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，移除最近最少使用的key。
- volatile-random：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，随机移除某个key。
- volatile-ttl：当内存不足以容纳新写入数据时，在设置了过期时间的键空间中，有更早过期时间的key优先移除。

```shell
config set maxmemory 100MB
config get maxmemory
config get maxmemery-policy
config set lru-simple 10
```



##### 2. 索引失效的场景

1）对于联合索引来说，不满足最左前缀匹配原则

如果是索引是（c1,c2,c3）,那么会给（c1)、（c1,c2)建立索引

```sql
select * from test where c2=1 &&c3=2    #索引失效
```

索引会向右匹配直到遇到范围查询 >  < between like 就停止匹配

2）模糊查询中，使用前置Like模糊查询

```sql
select * from test where c1 like %张   #索引失效
```

3）隐式类型转化 可能调用Cast

- 索引列是字符串时，如果传入的条件参数是整数，会先转换成浮点数，再全表扫描，导致索引失效；
- 条件参数要尽可能与列的类型相同，避免隐式转换，或者把传入的条件参数转换成索引列的类型。

4）where条件中对索引进行函数运算或者简单谓词运算即加减乘除这列

5）not，in ，not in，not exists

可以存在很多值并且分布分散，底层优化器判定执行计划可能更倾向于全表扫描

6）使用or

使用or连接的两个字段，如果两个字段都是索引字段索引才会生效，否则索引无效。

#### 一面

##### 1. 方法、属性修饰符  

外部类只能使用public 和缺省默认

public：公有的，对所有类都可见

private:私有的，仅对本类可见

protected:受保护的，对本包和子类都可见

默认不加修饰符：仅对本包可见

##### 2. varchar和char的区别

1)char 是固定长度的字符串，varchar是长度可变的字符串，char如果达不到固定长度，会用空格进行剩余空间填充

2)char的范围为0~255字节，varchar最大长度为65535，varchar会用开头1到2个字节记录长度

3）varchar之前是字节，5.0版本后是字符

> `GBK编码：`
> 一个英文字符占一个字节，中文2字节，单字符最大可占用2个字节。
>
> `UTF-8编码：`
> 一个英文字符占一个字节，中文3字节，单字符最大可占用3个字节。
>
> `utf8mb4编码：`
> 一个英文字符占一个字节，中文3字节，单字符最大占4个字节（如emoji表情4字节）。

##### 3. inner join  right join

- left join（左联接）：返回左表中的所有记录以及和右表中的联接字段相等的记录,联结字段不相等则为null。
- right join（右联接）：返回右表中的所有记录以及和左表中的联接字段相等的记录，联结字段不相等则为null。
- inner join（等值联接）：只返回两个表中联接字段相等的记录。

[关于左联结、右联结、内联结的例子](https://www.cnblogs.com/pcjim/articles/799302.html)

##### 4.== 和 equals

==分为基本数据类型和对象   equals分为对象的类有没有重写equals这个方法

**==**

它的作用是判断两个对象的地址是不是相等。即判断两个对象是不是同一个对象（基本数据类型==比较的是值，引用数据类型==比较的是内存地址）。

**equals()**

该方法定义在Object类中，因此Java中的每个类都具有该方法，它的作用也是判断两个对象是否相等。但它一般有两种使用情况：

- 情况1：类**没有覆盖** equals() 方法。则通过 equals() 比较该类的两个对象时，等价于通过“==”比较这两个对象。Object.java 源码如下：

```
public boolean equals(Object obj) {
    return (this == obj);
}
```

- 情况2：类**覆盖**了 equals() 方法。一般我们都覆盖 equals() 方法来比较两个对象的内容是否相等；若它们的内容相等，则返回 true (即认为这两个对象相等)。

```
public class Test {
    public static void main(String[] args) {
        String str1 = new String("abc");
        String str2 = new String("abc");
        System.out.println(str1 == str2);       // false
        System.out.println(str1.equals(str2));  // true，String类重写过equals()方法
        
        Integer i1 = new Integer(2);
        Integer i2 = new Integer(2);
        System.out.println(i1 == i2);       // false
        System.out.println(i1.equals(i2));  // true，8个基本数据类型的包装类重写过equals()方法
    }
}
```

##### 5.你怎么把秒杀系统搞崩

##### 6. int Integer的区别

int 是Java的基本数据类型。Integer 继承了Object类，是对象类型，是 int 的包装类。

基本数据类型int可以自动转化为包装类对象Integer，而包装类对象也可以自动转化为基本数据类型

Integer类里面有一个静态内部类`IntegerCache`，可以在静态代码块中保存一个-128-127的Integer数组，当你直接如Integer i=10时，它会判断这个值是否在这个区间，在，直接返回这个缓存池里的Integer对象，不在，在堆中新建一个Integer对象，如下面的类方法valueOf，会想方设法返回常量池中的值，new 的话直接在堆中创建一个对象，赋值的话先在常量池也就是这个数组里找，没有的话，直接在堆中创建一个对象返回

`Integer`和int 用==比较   会自动拆箱

`Integer` 和`Integer`比较，看你的内存地址了，关键是否在常量池或者堆中

`Byte、Short、Integer、Long、Character` 存在缓存池，默认范围都是 -128~127

```Java
//自动装箱
Integer a=10;
//自动拆箱
System.out.println(a+10);
```

Integer包装类也有常量池  Integer里的静态内部类`IntegerCache`

```Java
private static class IntegerCache {
        static final int low = -128;
        static final int high;
        static final Integer cache[];

        static {
            // high value may be configured by property
            int h = 127;
            String integerCacheHighPropValue =
                sun.misc.VM.getSavedProperty("java.lang.Integer.IntegerCache.high");
            if (integerCacheHighPropValue != null) {
                try {
                    int i = parseInt(integerCacheHighPropValue);
                    i = Math.max(i, 127);
                    // Maximum array size is Integer.MAX_VALUE
                    h = Math.min(i, Integer.MAX_VALUE - (-low) -1);
                } catch( NumberFormatException nfe) {
                    // If the property cannot be parsed into an int, ignore it.
                }
            }
            high = h;
			//主要逻辑为生成一个缓存数组，保存从-128到127的Integer对象的引用
            cache = new Integer[(high - low) + 1];
            int j = low;
            for(int k = 0; k < cache.length; k++)
                cache[k] = new Integer(j++);

            // range [-128, 127] must be interned (JLS7 5.1.7)使用断言，抛出错误
            assert IntegerCache.high >= 127;
        }

        private IntegerCache() {}
    }
  public static Integer valueOf(int i) {
        if (i >= IntegerCache.low && i <= IntegerCache.high)
            return IntegerCache.cache[i + (-IntegerCache.low)];
        return new Integer(i);
    }
```

##### 7.接口能实现方法吗,main方法

接口里的属性默认是 public static final

接口能实现方法，方式主要有2种，**静态接口方法，默认接口方法**，都能在接口里实现

Java 8后，接口等同于抽象类了，类中没有default\static标识的方法，都默认是abstract方法，子类必须实现

默认接口方法，子接口或者子类可以实现也可以不实现，静态接口方法不能实现，这个属于这个类的

**默认接口方法冲突**

如果实现了2个接口，这两个接口都有默认方法，方法名都相同，那么就会发生冲突，子类需要自己实现这个方法

但如果这两个接口有继承关系，就不会发生冲突，会使用子接口的方法

##### 默认接口方法优先于抽象方法

如果实现的父接口中有一个抽象方法，子接口中默认方法与抽象方法同名，优先默认接口方法

**接口中能实现main方法**

因为main方法是静态的

```Java
public interface testInterface {
    public static void main(String[] args) {
        System.out.println("hello");
    }
}
```

##### 8.抽象类能用final吗

不能，抽象类是被用于继承的，final修饰代表不可修改、不可继承的。

##### 9. float double

| type              |         | precision |
| ----------------- | ------- | --------- |
| float             | 4 bytes | 7位       |
| double            | 8 bytes | 15位      |
| decimal(精确数值) |         | 28位      |

decimal(a,b) a指定指定小数点左边和右边可以存储的十进制数字的最大个数，最大精度38。
b指定小数点右边可以存储的十进制数字的最大个数。小数位数必须是从 0 到 a之间的值。默认小数位数是 0。

##### 10. `hashmap` 和`hashtable`

1. **线程是否安全：** HashMap 是非线程安全的，Hashtable 是线程安全的；HashTable 内部的方法基本都经过`synchronized` 修饰（如果要保证线程安全的话推荐使用 ConcurrentHashMap ）。
2. **效率：** 因为线程安全的问题，HashMap 要比 Hashtable 效率高一点。另外，Hashtable 基本被淘汰，不要在代码中使用它。
3. **对null key 和null value的支持：** HashMap 中，null 可以作为键，这样的键只有一个，可以有一个或多个键所对应的值为 null。但是在 Hashtable 中 put 进的键值只要有一个 null，直接抛出 NullPointerException。
4. **初始容量大小和每次扩充容量大小的不同 ：** ①创建时如果不指定容量初始值，Hashtable 默认的初始大小为11，之后每次扩充，容量变为原来的 2n+1。HashMap 默认的初始化大小为16。之后每次扩充，容量变为原来的 2 倍。②创建时如果给定了容量初始值，那么 Hashtable 会直接使用你给定的大小，而 HashMap 会将其扩充为2的幂次方大小，也就是说 HashMap 总是使用2的幂作为哈希表的大小。
5. **底层数据结构：** JDK 8 以后的 HashMap 在解决哈希冲突时有了较大的变化，当链表长度大于阈值（默认为8）时，将链表转化为红黑树，以减少搜索时间。Hashtable 没有这样的机制。

hashtable为什么不支持null值

##### 11. `hashmap`的使用场景   `concurrenthashmap`

##### 12. `BIO NIO AIO`



